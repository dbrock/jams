<!doctype html>
<meta charset=utf8>
<meta name=viewport content=width=device-width>
<script src=jams.js></script>
<script>
  info = (...xs) => console.log(...xs), puts = x => document.write(x)
  html = x => x.replace(/</g, "&lt;").replace(/&/g, "&amp;")
  show = x => typeof x == "string" ? JSON.stringify(x) : x
  rand = x => (seed = seed * 75 % 65537) % x, seed = 1
  iota = x => [...Array(x).keys()], iotr = x => iota(rand(x))
  pick = (xs, x) => iota(x).map(x => xs[rand(xs.length)])
  snag = f => { try { f() } catch (x) { return x } }
  keys = x => Object.keys(x), dict = xs => Object.fromEntries(xs)
  some = xs => pick(xs, 1)[0], ambi = fs => some(fs)()
  rand_chr = () => ambi([rand_chr_spc, rand_chr_bmp, rand_chr_ast])
  rand_chr_spc = () => some(" \r\n\t\"[]{}".split(""))
  rand_chr_bmp = () => String.fromCharCode(rand(2e16))
  rand_chr_ast = () => String.fromCharCode(2e16 + rand(1000))
  rand_val = () => ambi([rand_arr, rand_obj, rand_str, rand_bad])
  rand_arr = () => iotr(4).map(rand_val)
  rand_obj = () => dict(iotr(3).map(x => [rand_str(), rand_val()]))
  rand_str = () => ambi([rand_str1, () => show(rand_str())])
  rand_str1 = () => pick(keys(this), rand(3)).join(rand_chr())
  rand_bad = () => ambi([rand_bad1, rand_bad2, rand_bad3])
  rand_bad1 = () => pick([null, undefined, false, NaN, Infinity])
  rand_bad2 = () => rand(10e5) / rand(10e5) * (rand(2) - 1)
  rand_bad3 = () => pick([/foo/, new Date(10e7), () => null])
</script>
<h3>Success tests</h3>
<p>Check that <code>JAMS.parse(JAMS.stringify(x))</code> does
nothing after <code>JAMS.normalize</code>, which we also sanity check.
<script>
  size = 1000, seed = init = Math.floor(Math.random() * 10e6)
  for (let i = 1; i <= size; i++) {
    info(
      `#${i}/${seed}:`,
      show(w = rand_val()),
      show(x = JAMS.normalize(w)),
      y_jams = JAMS.stringify(x)
    )

    let strs = x => JSON.stringify(x).replace(/"/g, "")
    if (strs(x) != strs(w)) {
      throw new Error(`Normalized value does not match raw value`)
    }

    if (JSON.stringify(x) != JSON.stringify(y = JAMS.parse(y_jams))) {
      info(`Unexpected:`, show(y))
      puts(`<p>&times; Falied roundtrip; see console for details`)
      throw new Error(`Failed roundtrip`)
    }
  }

  puts(`<pre style="white-space: pre-wrap; line-break: anywhere">
// Example of random value:
w = ${html(JSON.stringify(w, null, 2))}

// Sanity check:
x = JAMS.normalize(w)
strs = x => toJSON(x).replace(/"/g, "")
assert(strs(x) == strs(w))

// Result of JAMS.stringify(x):
// ${html(JAMS.stringify(x))}

// Check that we get the same value back again:
y = JAMS.parse(JAMS.stringify(x))
assert(JSON.stringify(y) == JSON.stringify(x))</pre>
<p>Successfully checked ${size.toLocaleString()} random values
(random seed ${init.toLocaleString()}).`)
</script>
<h3>Failure tests</h3>
<p>Check that the error messages are as we expect for the following
manual examples of bad input.
<script>
  flop = (x, y) => {
    let error = snag(() => JAMS.parse(x))
    if (error && error.message == y) {
      puts(`<pre>&check; JAMS.parse(${show(x)})\n> ${y}</pre>`)
    } else {
      puts(`<pre>&times; JAMS.parse(${show(x)})\n&lt; ${y}\n`)
      puts(`> ${error ? error.message : "(did not fail at all)"}</pre>`)
      throw new Error(`Failed error message test`)
    }
  }

  flop(`]`, "Expected expression, found `]' (line 1, column 1)")
  flop(`"foo\n`, "Expected end quote, found `\\n' (line 1, column 5)")
  flop(`[foo{}]`, "Expected whitespace, found `{' (line 1, column 5)")
  flop(`{foo}`, "Expected whitespace, found `}' (line 1, column 5)")
  flop(`{a c a b}`, "Duplicate key `a' (line 1, column 6)")
  flop(`a c a b`, "Duplicate key `a' (line 1, column 5)")
  flop(`a b c`, "Expected whitespace, found end of file (line 1, column 6)")

  puts(`<p>Successfully checked all failure cases.`)
</script>
